<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="ModuleA21_old" Id="{1fbfe76c-9167-499a-b0fc-417506667913}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ModuleA21_old
VAR
	execute : BOOL;
	stop : BOOL;
	generalError : BOOL;
	failLeft, failRight : BOOL;
	
	manualStep : BOOL := TRUE;
	manualSuction : BOOL := FALSE;
END_VAR
VAR //local types
	woodBunkArr : ARRAY[0..GVL.maxPairs] OF PositionMaterials;
	
	stagingTemplateLeft, stagingTemplateRight AT %M* : WoodBunkTable; //declaration with %M* overwrites addresses of local attributes
	stagingArrayLeft, stagingArrayRight : ARRAY[0..GVL.maxPairs*2] OF STRING;
	insertionLeft, insertionRight : Insertion;
END_VAR
VAR //for testing, to be removed when replaced with pressure sensors
	latchLeft, latchRight : BOOL; //prevents SMC sliders from overshooting the inner limit sensor
	
	suctionEnableTop : BOOL;
	suctionEnableLeft : BOOL;
	suctionEnableRight : BOOL;
	suctionEnableBottom : BOOL;
	
	done : BOOL;
	
	demoPairWB : PositionMaterials := (
		position := 0,
		top := 'WDS20',
		left := 'WDS20',
		right := 'WDS20',
		bottom := 'WDS14');
		
	demoPairCIP : PositionMaterials := (
		position := 0,
		top := 'CIP54',
		bottom := 'CIP18');
	
	demoHeight : REAL := 600; //mm
END_VAR
VAR
	//robotLeftOutputs, robotRightOutputs : ARRAY[1..11] OF INT;
	
	insertionMaterials : ARRAY[Surface.TOP..Surface.BOTTOM] OF STRING;
	//robotLeftMaterial, robotRightMaterial : STRING;
	
	topSuctionDelay : TON;
	
	step : (IDLE, LOAD_CIP, STAGING, LOAD_WB, PUSH, STRAP, RELEASE, COMPLETE := 1050);
	
	//these 2 ints should replace the 4 ints after
	commandSet : INT;
	commandStepLeft, commandStepRight : INT;
	
	loadSet : INT;
	loadStepLeft, loadStepRight : INT;
	
	stageSet : INT;	
	stageStepLeft, stageStepRight : INT;
	iSlotLeft, iSlotRight : INT(1..10);
END_VAR
VAR //CONSTANT
	sectionID : SectionEnum := SectionEnum.CHIPBOARD;
	idleRobotOutput : ARRAY[1..11] OF INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[SetupHardware();
CallHardwareModules();
callLocalModules();

woodBunkArr[0] := demoPairWB;

IF stop THEN //may need to turn off suction
	insertionLeft.stop();
	insertionRight.stop();
	pistonBottom.stop();
	
	robotLeft.clearCommand();
	robotRight.clearCommand();
	RETURN;
END_IF


IF NOT (insertionLeft.screw.HomeSet AND insertionRight.screw.HomeSet) THEN
	insertionLeft.homingSequence();
	insertionRight.homingSequence();
	pistonBottom.retract();
	RETURN;
END_IF


CASE step OF
	IDLE:
		IF execute THEN
			execute := FALSE;
			suctionEnableTop := suctionEnableLeft := suctionEnableRight := suctionEnableBottom := FALSE;
			step := STAGING;
		END_IF
		
		SetSuctions(topSuction, suctionEnableTop);
		SetSuctions(leftSuction, suctionEnableLeft);
		SetSuctions(rightSuction, suctionEnableRight);
		SetSuctions(bottomSuction, suctionEnableBottom);
		
	LOAD_CIP:
		IF NOT done THEN
			done := loadCIP(pair:= demoPairWB, error => generalError);
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			done := FALSE;
			execute := FALSE;
			
			step := STAGING;
		END_IF
		
	STAGING:
		IF NOT done THEN
			done := stage(error => generalError);
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			execute := FALSE;
			done := FALSE;
			step := LOAD_WB;
		END_IF
	
	LOAD_WB:
		IF NOT done THEN
			done := loadWB(pair := demoPairWB, error => generalError);
		END_IF
		
		IF manualSuction THEN
			SetSuctions(topSuction, suctionEnableTop);
			SetSuctions(leftSuction, suctionEnableLeft);
			SetSuctions(rightSuction, suctionEnableRight);
			SetSuctions(bottomSuction, suctionEnableBottom);
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			done := FALSE;
			suctionEnableTop := suctionEnableLeft := suctionEnableRight := suctionEnableBottom := FALSE;
			execute := FALSE;
			
			step := PUSH;
		END_IF
		
	PUSH:
		(*
		IF 
			insertionLeft.sliderPos <> demoHeight/2 //OR 
			//insertionRight.sliderPos <> demoHeight/2 //OR 
			//NOT insertionBottom.contact
		THEN
			insertionLeft.slideAbsolute(demoHeight/2);
			//insertionRight.slideAbsolute(demoHeight/2);
			RETURN;
		END_IF
		*)
		
		IF insertionLeft.screw.AtInnerLimit THEN
			latchLeft := TRUE;
		ELSIF NOT latchLeft THEN
			insertionLeft.press();
		END_IF
		
		IF insertionRight.screw.AtInnerLimit THEN
			latchRight := TRUE;
		ELSIF NOT latchRight THEN
			insertionRight.press();
		END_IF
		pistonBottom.extend();
		
		IF
			(manualStep AND_THEN execute) OR
			(latchLeft AND latchRight (*AND insertionBottom.extended*))
		THEN
			latchLeft := latchRight := FALSE;
			execute := FALSE;
			step := STRAP;
		END_IF
		
	STRAP:
		topSuctionDelay(IN:= , PT:= T#1S, Q=> , ET=> );
		
		strapper.bEnable := TRUE;
		IF strapper.done THEN
			topSuctionDelay.IN := FALSE;
			step := RELEASE;
			RETURN;
		END_IF
		
		IF topSuctionDelay.Q THEN
			SetSuctions(topSuction, FALSE);
			SetSuctions(leftSuction, FALSE);
			SetSuctions(rightSuction, FALSE);
			SetSuctions(bottomSuction, FALSE);
		ELSIF strapper.atBundleLevel THEN
			topSuctionDelay.IN := TRUE;
		END_IF
		
		IF strapper.ready THEN
			strapper.strap();
		END_IF
		
		IF execute THEN
			topSuctionDelay.IN := FALSE;
			execute := FALSE;
			step := RELEASE;
		END_IF
		
	RELEASE: //release command		
		//insertionLeft.slideAbsolute(0);
		//insertionRight.slideAbsolute(0);
		
		insertionLeft.release();
		insertionRight.release();
		pistonBottom.retract();
		
		IF 
			(insertionLeft.screw.AtHome AND insertionRight.screw.AtHome AND pistonBottom.retracted) OR
			execute
		THEN
			execute := FALSE;
			step := COMPLETE;
		END_IF
	
	COMPLETE:
		//reset everything
		step := IDLE;
		
END_CASE

CallHardwareModules(); //end program with hardware call]]></ST>
    </Implementation>
    <Folder Name="Load CIP" Id="{a74b5861-19ee-486d-a039-c27096a2f5ea}" />
    <Folder Name="Load WB" Id="{f653cb75-c421-4c99-8b54-47ea79e491e7}" />
    <Folder Name="Staging" Id="{22e41a91-8aae-4dcf-bbc7-b5de79663f48}">
      <Folder Name="Staging Template" Id="{31bcfea3-222f-4d16-9b5d-54c26b1d9773}" />
    </Folder>
    <Folder Name="x_Reworking" Id="{0c7119d8-3192-43b6-acb5-88e1eb3780e9}" />
    <Method Name="callLocalModules" Id="{959ae452-8eca-463e-9f32-a920acaef287}">
      <Declaration><![CDATA[METHOD callLocalModules : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[stagingTemplateLeft();
stagingTemplateRight();

insertionLeft(
	enable:= TRUE, 
	slider:= verticalDriveLeft, 
	screw:= horizontalDriveLeft, 
	contact=> , 
	softContact=> , 
	busy=> , 
	error=> , 
	home=> , 
	homingComplete=> , 
	sliderPos=> );
	
insertionRight(
	enable:= TRUE, 
	slider:= verticalDriveRight, 
	screw:= horizontalDriveRight,  
	contact=> , 
	softContact=> , 
	busy=> , 
	error=> , 
	home=> , 
	homingComplete=> , 
	sliderPos=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="changeRobotsEOAT" Id="{9dd1ff6b-6232-48ab-a48a-465203b0d253}">
      <Declaration><![CDATA[METHOD changeRobotsEOAT : BOOL
VAR_IN_OUT
	robot : RobotA21;
END_VAR
VAR_INPUT
	targetTool : SectionEnum;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF robotLeft.tool <> targetTool THEN
	CASE targetTool OF
		SectionEnum.CHIPBOARD:	robot.setGroup(group := 1, value := A21.TOOL_CHANGE_CHIPBOARD);
		SectionEnum.WOOD_BUNK:	robot.setGroup(group := 1, value := A21.TOOL_CHANGE_BUNK);
	END_CASE
END_IF

(*
IF robot.gripper.id <> targetTool THEN
	CASE targetTool OF
		SectionEnum.CHIPBOARD:	robot.setGroup(group := 1, value := A21.TOOL_CHANGE_CHIPBOARD);
		SectionEnum.WOOD_BUNK:	robot.setGroup(group := 1, value := A21.TOOL_CHANGE_BUNK);
	END_CASE
END_IF

changeRobotsEOAT := robot.gripper.id = targetTool;
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="createStagingArrayLeft" Id="{59420fd1-9216-4032-946e-d3c82e9a88d7}" FolderPath="Staging\Staging Template\">
      <Declaration><![CDATA[METHOD createStagingArrayLeft : BOOL
VAR
	remainingMaterial : STRING;
	splitMaterial : STRING;
	
	i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO GVL.maxPairs BY 1 DO
	remainingMaterial := woodBunkArr[i].top;
	WHILE FIND(remainingMaterial, '_') > 0 DO
		splitCombinedMaterials(remainingMaterial, splitMaterial);
		IF splitMaterial <> '' THEN
			AddToStringArray(arr := stagingArrayLeft, newString := splitMaterial, numElements => , nextIndex => );
		END_IF
	END_WHILE
	
	IF remainingMaterial <> '' THEN
		AddToStringArray(arr := stagingArrayLeft, newString := remainingMaterial, numElements => , nextIndex => );
	END_IF
	
	
	remainingMaterial := woodBunkArr[i].left;
	WHILE FIND(remainingMaterial, '_') > 0 DO
		splitCombinedMaterials(remainingMaterial, splitMaterial);
		IF splitMaterial <> '' THEN
			AddToStringArray(arr := stagingArrayLeft, newString := splitMaterial, numElements => , nextIndex => );
		END_IF
	END_WHILE
	
	IF remainingMaterial <> '' THEN
		AddToStringArray(arr := stagingArrayLeft, newString := remainingMaterial, numElements => , nextIndex => );
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="createStagingArrayRight" Id="{bd8ca19d-905a-4b91-a7cc-ee201d354996}" FolderPath="Staging\Staging Template\">
      <Declaration><![CDATA[METHOD createStagingArrayRight : BOOL
VAR
	remainingMaterial : STRING;
	splitMaterial : STRING;
	
	i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO GVL.maxPairs*2 BY 1 DO
	remainingMaterial := woodBunkArr[i].bottom;
	WHILE FIND(remainingMaterial, '_') > 0 DO
		splitCombinedMaterials(remainingMaterial, splitMaterial);
		IF splitMaterial <> '' THEN
			AddToStringArray(arr := stagingArrayRight, newString := splitMaterial, numElements => , nextIndex => );
		END_IF
	END_WHILE
	
	IF remainingMaterial <> '' THEN
		AddToStringArray(arr := stagingArrayRight, newString := remainingMaterial, numElements => , nextIndex => );
	END_IF
	
	
	
	remainingMaterial := woodBunkArr[i].right;
	WHILE FIND(remainingMaterial, '_') > 0 DO
		splitCombinedMaterials(remainingMaterial, splitMaterial);
		IF splitMaterial <> '' THEN
			AddToStringArray(arr := stagingArrayRight, newString := splitMaterial, numElements => , nextIndex => );
		END_IF
	END_WHILE
	
	IF remainingMaterial <> '' THEN
		AddToStringArray(arr := stagingArrayRight, newString := remainingMaterial, numElements => , nextIndex => );
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="generateStagingTemplate" Id="{e40b10d6-6230-463e-b6e9-663fa22c1a43}" FolderPath="Staging\Staging Template\">
      <Declaration><![CDATA[METHOD PROTECTED generateStagingTemplate : BOOL
VAR
	remainingMaterial : STRING;
	splitMaterial : STRING;
	
	i : INT;
END_VAR
VAR_STAT
	temp : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[createStagingArrayLeft();
createStagingArrayRight();

//AddToStringArray(arr := stagingArrayLeft, newString := 'WDB20', numElements =>, nextIndex => );

(*
iterate through all pairs and autofill the template
replace succesfully autofilled materials with empty string

when staging needs to be performed a 2nd time, autofilling empty strings is always unsuccessful
*)
FOR i:=0 TO GVL.maxPairs*2 BY 1 DO
	IF stagingTemplateLeft.autofill(materialID := stagingArrayLeft[i]) THEN
		stagingArrayLeft[i] := '';
	END_IF
	
	IF stagingTemplateRight.autofill(materialID := stagingArrayRight[i]) THEN
		stagingArrayRight[i] := '';
	END_IF
END_FOR

(*
stagingTemplateLeft.autofill(demoPairWB.top);
stagingTemplateLeft.autofill(demoPairWB.left);

stagingTemplateRight.autofill(demoPairWB.right);
stagingTemplateRight.autofill(demoPairWB.bottom);
*)

generateStagingTemplate := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadCIP" Id="{d5167b28-e43b-4b89-8638-9f345e1029a5}" FolderPath="Load CIP\">
      <Declaration><![CDATA[METHOD loadCIP : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[sectionID := SectionEnum.CHIPBOARD;

IF NOT robotLeft.operational AND NOT robotLeft.operational THEN //robots not operational
	error := TRUE;
	RETURN;
END_IF

IF NOT (robotLeft.reserve(sectionID) AND robotRight.reserve(sectionID)) THEN //robots not reserved
	RETURN;
END_IF

IF NOT (robotLeft.tool = sectionID AND robotRight.tool = sectionID) THEN //robots have wrong tool
	changeRobotsEOAT(robot := robotLeft, targetTool := sectionID); //wait for robots to finish changing tools
	changeRobotsEOAT(robot := robotRight, targetTool := sectionID);
	RETURN;
END_IF
//robots ok

CASE loadSet OF
	0: //demo only - only top chipboard loaded by left robot
		IF 
			loadingSequenceCIP(
				robot:= robotLeft, 
				storage:= skidLeft, 
				loadStep:= loadStepLeft, 
				surfaceID:= Surface.TOP,
				material:= pair.top, 
				fail=> )
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := 10;
		END_IF
		
	10: //recovery
		IF robotLeft.operational AND NOT robotRight.operational THEN //left ok, right fail
			IF //load bottom using left robot
				loadingSequenceCIP(
					robot:= robotLeft, 
					storage:= skidLeft, 
					loadStep:= loadStepLeft, 
					surfaceID:= Surface.BOTTOM,
					material:= pair.top, 
					fail=> ) //load bottom with left robot
			THEN
				loadSet := COMPLETE;
			END_IF
			
		ELSIF NOT robotLeft.operational AND robotRight.operational THEN //left fail, right ok
			IF //load top using right robot
				loadingSequenceCIP(
					robot:= robotRight, 
					storage:= skidRight, 
					loadStep:= loadStepRight, 
					surfaceID:= Surface.TOP,
					material:= pair.bottom, 
					fail=> ) //load top with right robot
			THEN
				loadSet := COMPLETE;
			END_IF
			
		END_IF
		
	COMPLETE:
		loadSet := 0;
		loadStepLeft := loadStepRight := 0;
		
		robotLeft.release(sectionID);
		robotRight.release(sectionID);
		
		loadCIP := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadingSequenceCIP" Id="{6da6d1f9-64c0-42e2-8e8f-19613d4e1674}" FolderPath="Load CIP\">
      <Declaration><![CDATA[METHOD loadingSequenceCIP : BOOL
VAR_IN_OUT
	robot : RobotA21;
	storage : MaterialHolder;
	loadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadingSequenceCIP := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0:
		robot.clearCommand();
		IF robot.Ready THEN
			step := 10;
		END_IF
		
	10: //grab from chipboard skid
		IF NOT storage.findSlot(materialID := material, atSlot => slot) THEN
			fail := TRUE;
			RETURN;
		ELSIF surfaceID = Surface.BOTTOM (*AND_THEN (*conveyor not lowered*)*) THEN
			//lower conveyor
			RETURN;
		END_IF
		
		IF robot.Done THEN
			step := COMPLETE;
			RETURN;
		END_IF
		
		robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TO_TOP);
		robot.setGroup(group := 2, value := slot);
	(*	
	20: //in between pause
		robot.clearCommand();
		IF robot.Ready THEN
			step := 30;
		END_IF
		
	30: //move to bundle
		MEMSET(ADR(command), 0, SIZEOF(command));
		CASE surfaceID OF
			Surface.TOP: 					robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TO_TOP);
			Surface.BOTTOM: 				robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TO_BOTTOM);
		END_CASE		
		//robot.setGroup(group := 2, value := slot);
		
		IF robot.setCommand(command) THEN
			loadStep := 10;
		END_IF
	*)
	COMPLETE:
		robot.release(sectionID);
		loadingSequenceCIP := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadingSequenceWB" Id="{1ab7b181-87ec-45fa-b3bc-70991594b81e}" FolderPath="Load WB\">
      <Declaration><![CDATA[METHOD loadingSequenceWB : BOOL
VAR_IN_OUT
	robot : RobotA21;
	//carryMaterial : STRING;
	table : WoodBunkTable;
	suctions : ARRAY[*] OF SuctionPad;
	loadStep : INT;
	slot : INT(1..10);
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	i : DINT;
END_VAR
VAR_STAT
	tempSlot : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadingSequenceWB := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0: //wait for robot
		robot.clearCommand();
		
		IF robot.Ready THEN
			loadStep := 10;
		END_IF
		
	10: //grab from table
		IF NOT table.findSlot(materialID := material, atSlot => slot) (*AND slot < 1*) THEN	//cannot find material on table	
			
			fail := TRUE;
			RETURN;
		END_IF
		tempSlot := slot;
		IF NOT table.occupied[slot] AND robot.suspendedMaterial = '' THEN //move from table to robot gripper
			robot.CarryMaterial := table.slots[slot];
			table.remove(i := slot, materialID => );
		END_IF
		
		IF robot.Done THEN
			loadStep := COMPLETE;
			RETURN;
		ELSIF robot.materialAtHoldingPosition >= 1 AND robot.materialAtHoldingPosition <= 8 THEN
			loadStep := 20;
			RETURN;
		END_IF
		
		CASE surfaceID OF
			Surface.TOP: 					robot.setGroup(group := 1, value := A21.LOAD_BUNK_TO_TOP); 
			Surface.LEFT, Surface.RIGHT: 	robot.setGroup(group := 1, value := A21.LOAD_BUNK_TO_SIDE);
			Surface.BOTTOM: 				robot.setGroup(group := 1, value := A21.LOAD_BUNK_TO_BOTTOM);
		END_CASE
		robot.setGroup(group := 2, value := slot); 
			
	20: //place to insertion
		IF robotLeft.Done THEN
			loadStep := COMPLETE;
			RETURN;
		END_IF
		
		robot.setGroup(group := 9, value := robot.inputs[5]);
		
		IF robot.materialAtHoldingPosition > 0 AND robot.CarryMaterial <> '' THEN //move from gripper to insertion
			IF insertionMaterials[surfaceID] = '' THEN //transfer to insertion as is
				insertionMaterials[surfaceID] := robot.suspendedMaterial;
			ELSE //join with existing material using underscore _
				insertionMaterials[surfaceID] := JoinStrings(insertionMaterials[surfaceID], robot.suspendedMaterial, '_');
			END_IF
			robot.CarryMaterial := '';
		END_IF
		
		CASE surfaceID OF
			Surface.TOP, Surface.BOTTOM:
				SetSuctions(suctions, TRUE (*robot.materialAtHoldingPosition = 1 OR robot.materialAtHoldingPosition = 4*));
				
			Surface.LEFT, Surface.RIGHT:
				SetSuctions(suctions, TRUE (*robot.materialAtHoldingPosition = 2 OR robot.materialAtHoldingPosition = 3*));
				(*
				FOR i:=LOWER_BOUND(suctions, 1) TO UPPER_BOUND(suctions, 1) BY 1 DO
					
					IF i < UPPER_BOUND(suctions, 1)/2 THEN
						suctions[i].enable := robot.materialAtHoldingPosition = 2; //enable upper half suctions
					ELSE
						suctions[i].enable := robot.materialAtHoldingPosition = 3; //enable lower half suctions
					END_IF

				END_FOR
				*)
		END_CASE
	
	COMPLETE:
		robot.clearCommand();
		loadingSequenceWB := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadingSequenceWB_old" Id="{a556360f-edcd-4c0a-b161-1de57bfa45b3}" FolderPath="x_Reworking\">
      <Declaration><![CDATA[METHOD loadingSequenceWB_old : BOOL
VAR_IN_OUT
	robot : RobotA21;
	commands : ARRAY[1..11] OF INT;
	carryMaterial : STRING;
	table : WoodBunkTable;
	suctions : ARRAY[*] OF SuctionPad;
	loadStep : INT;
	slot : INT(1..10);
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	i : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadingSequenceWB_old := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0: //wait for robot
		IF robot.Ready THEN
			loadStep := 10;
		END_IF
		
	10: //grab from table
		IF NOT table.findSlot(materialID := material, atSlot => slot) (*AND slot < 1*) THEN	//cannot find material on table	
			fail := TRUE;
			RETURN;
		END_IF
		
		IF NOT table.occupied[slot] AND carryMaterial = '' THEN //move from table to robot gripper
			table.remove(i := slot, materialID => carryMaterial);
		END_IF
		
		IF robot.inputs[5] > 0 THEN
			loadStep := 20;
			RETURN;
		END_IF		
		
		MEMSET(ADR(commands), 0, SIZEOF(commands));
		CASE surfaceID OF
			Surface.TOP: 					commands[1] := A21.LOAD_BUNK_TO_TOP;
			Surface.LEFT, Surface.RIGHT: 	commands[1] := A21.LOAD_BUNK_TO_SIDE;
			Surface.BOTTOM: 				commands[1] := A21.LOAD_BUNK_TO_BOTTOM;
		END_CASE
		commands[2] := slot;
		robot.setCommand(commands);
			
	20: //place to insertion
		IF robotLeft.Done THEN
			loadStep := COMPLETE;
			RETURN;
		END_IF
		
		robot.setCommand(commands);
		robot.setGroup(group := 9, value := robot.inputs[5]);
		
		IF robot.inputs[5] > 0 THEN //move from gripper to insertion
			IF insertionMaterials[surfaceID] = '' THEN //transfer to insertion as is
				insertionMaterials[surfaceID] := carryMaterial;
			ELSE //join with existing material using underscore _
				insertionMaterials[surfaceID] := CONCAT(insertionMaterials[surfaceID], '_');
				insertionMaterials[surfaceID] := CONCAT(insertionMaterials[surfaceID], carryMaterial);
			END_IF
			carryMaterial := '';
		END_IF
		
		CASE surfaceID OF
			Surface.TOP, Surface.BOTTOM:
				SetSuctions(suctions, robot.inputs[5] = 1);
				
			Surface.LEFT, Surface.RIGHT:
				FOR i:=LOWER_BOUND(suctions, 1) TO UPPER_BOUND(suctions, 1) BY 1 DO
					
					IF i < UPPER_BOUND(suctions, 1)/2 THEN
						suctions[i].enable := robot.inputs[5] = 2; //enable upper half suctions
					ELSE
						suctions[i].enable := robot.inputs[5] = 3; //enable lower half suctions
					END_IF

				END_FOR
				(*
				suctions[1].enable := robot.inputs[5] = 2;
				suctions[2].enable := robot.inputs[5] = 2;
				
				suctions[3].enable := robot.inputs[5] = 3;
				suctions[4].enable := robot.inputs[5] = 3;
				*)
		END_CASE
		(*
		CASE robot.inputs[5] OF
			1, 4: //top/bottom insertions - enable all suctions
				SetSuctions(suctions, TRUE);
				
			2: //side insertion - enable upper half suctions
				suctions[1].enable := TRUE;
				suctions[2].enable := TRUE;
			
			3: //side insertion - enable lower half suctions
				suctions[3].enable := TRUE;
				suctions[4].enable := TRUE;
			
		END_CASE
		*)
	
	COMPLETE:
		robot.clearCommand();
		MEMSET(ADR(commands), 0, SIZEOF(commands));
		loadingSequenceWB_old := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadingSequenceWB_simple" Id="{7c812a92-d79c-4eeb-9188-e8f27b953f9a}" FolderPath="x_Reworking\">
      <Declaration><![CDATA[METHOD loadingSequenceWB_simple : BOOL
VAR_IN_OUT
	robot : RobotA21;
	commands : ARRAY[1..11] OF INT;
	carryMaterial : STRING;
	table : WoodBunkTable;
	suctions : ARRAY[*] OF SuctionPad;
	loadStep : INT;
	slot : INT(1..10);
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	i : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadingSequenceWB_simple := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0: //wait for robot
		IF robot.Ready THEN
			loadStep := 10;
		END_IF
		
	10: //grab from table
		IF NOT table.findSlot(materialID := material, atSlot => slot) (*AND slot < 1*) THEN	//cannot find material on table	
			fail := TRUE;
			RETURN;
		END_IF
		
		IF robotLeft.Done THEN
			loadStep := COMPLETE;
			RETURN;
		END_IF
		
		IF
			robot.inputs[5] > 0 AND  //robot is holding wood bunk at insertion position
			carryMaterial <> '' //robot gripper is carrying a wood bunk
		THEN
			//move from gripper to insertion
			IF insertionMaterials[surfaceID] = '' THEN //transfer to insertion as is
				insertionMaterials[surfaceID] := carryMaterial;
			ELSE //join with existing material using underscore _
				insertionMaterials[surfaceID] := CONCAT(insertionMaterials[surfaceID], '_');
				insertionMaterials[surfaceID] := CONCAT(insertionMaterials[surfaceID], carryMaterial);
			END_IF
			carryMaterial := '';
			
		ELSIF
			NOT table.occupied[slot] AND //table slot is vacant
			table.slots[slot] <> '' AND //table slot had a wood bunk on it
			carryMaterial <> '' //robot gripper is vacant
		THEN
			table.remove(i := slot, materialID => carryMaterial); //move from table to robot gripper
			
		END_IF		
		
		MEMSET(ADR(commands), 0, SIZEOF(commands));
		CASE surfaceID OF
			Surface.TOP: 					commands[1] := A21.LOAD_BUNK_TO_TOP;
			Surface.LEFT, Surface.RIGHT: 	commands[1] := A21.LOAD_BUNK_TO_SIDE;
			Surface.BOTTOM: 				commands[1] := A21.LOAD_BUNK_TO_BOTTOM;
		END_CASE
		commands[2] := slot;
		
		robot.setCommand(commands);
		robot.setGroup(group := 9, value := robot.inputs[5]);
		
		CASE surfaceID OF
			Surface.TOP, Surface.BOTTOM:
				SetSuctions(suctions, robot.inputs[5] = 1);
				
			Surface.LEFT, Surface.RIGHT:
				FOR i:=LOWER_BOUND(suctions, 1) TO UPPER_BOUND(suctions, 1) BY 1 DO
					
					IF i < UPPER_BOUND(suctions, 1)/2 THEN
						suctions[i].enable := robot.inputs[5] = 2; //enable upper half suctions
					ELSE
						suctions[i].enable := robot.inputs[5] = 3; //enable lower half suctions
					END_IF

				END_FOR
				(*
				//if the FOR loop does not work, use this
				suctions[1].enable := robot.inputs[5] = 2;
				suctions[2].enable := robot.inputs[5] = 2;
				
				suctions[3].enable := robot.inputs[5] = 3;
				suctions[4].enable := robot.inputs[5] = 3;
				*)
		END_CASE
		(*
		//if the above does not work, revert to this
		CASE robot.inputs[5] OF
			1, 4: //top/bottom insertions - enable all suctions
				SetSuctions(suctions, TRUE);
				
			2: //side insertion - enable upper half suctions
				suctions[1].enable := TRUE;
				suctions[2].enable := TRUE;
			
			3: //side insertion - enable lower half suctions
				suctions[3].enable := TRUE;
				suctions[4].enable := TRUE;
		END_CASE
		*)		
	
	COMPLETE:
		robot.clearCommand();
		MEMSET(ADR(commands), 0, SIZEOF(commands));
		loadingSequenceWB_simple := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadWB" Id="{c6434cc2-c10d-41de-b715-bb701aeeeaa1}" FolderPath="Load WB\">
      <Declaration><![CDATA[METHOD PROTECTED loadWB : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR
VAR_STAT
	leftMaterial : STRING;
	rightMaterial : STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[sectionID := SectionEnum.WOOD_BUNK;

(*
IF NOT robotLeft.operational OR NOT robotLeft.operational THEN
	error := TRUE;
	RETURN;
END_IF
*)

IF robotLeft.error OR robotRight.error THEN
	error := TRUE;
	RETURN;
	
ELSIF NOT (robotLeft.reserve(sectionID) AND robotRight.reserve(sectionID)) THEN //loading requires both robots be reserved together
	RETURN;
	
ELSIF
	(robotLeft.tool <> sectionID AND_THEN NOT changeRobotsEOAT(robot := robotLeft, targetTool := sectionID)) OR
	(robotRight.tool <> sectionID AND_THEN NOT changeRobotsEOAT(robot := robotRight, targetTool := sectionID))
	//NOT (robotLeft.tool = sectionID AND robotRight.tool = sectionID) 
THEN //robots have wrong tool
	//changeRobotsEOAT(robot := robotLeft, targetTool := sectionID); //wait for robots to finish changing tools
	//changeRobotsEOAT(robot := robotRight, targetTool := sectionID);
	RETURN;
END_IF
failLeft := FALSE;
failRight := FALSE;

CASE loadSet OF
	0: //top and bottom
		leftMaterial := pair.top;
		rightMaterial := pair.bottom;
		IF 
			loadingSequenceWB(
				robot:= robotLeft, 
				table:= stagingTableLeft, 
				loadStep:= loadStepLeft, 
				slot:= iSlotLeft,
				suctions:= topSuction,
				surfaceID:= Surface.TOP, 
				material:= pair.top, 
				fail=> failLeft)
			
			AND
			loadingSequenceWB(
				robot:= robotRight,
				table:= stagingTableRight, 
				loadStep:= loadStepRight, 
				slot:= iSlotRight,
				suctions:= bottomSuction,
				surfaceID:= Surface.BOTTOM, 
				material:= pair.bottom, 
				fail=> failRight)
			
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := 10;
		END_IF
		
	10: //sides
		leftMaterial := pair.left;
		rightMaterial := pair.right;
		IF
			loadingSequenceWB(
				robot:= robotLeft, 
				table:= stagingTableLeft, 
				loadStep:= loadStepLeft, 
				slot:= iSlotLeft,
				suctions:= leftSuction,
				surfaceID:= Surface.LEFT, 
				material:= pair.left, 
				fail=> )
			
			AND
			loadingSequenceWB(
				robot:= robotRight, 
				table:= stagingTableRight, 
				loadStep:= loadStepRight, 
				slot:= iSlotRight,
				suctions:= rightSuction,
				surfaceID:= Surface.RIGHT, 
				material:= pair.right, 
				fail=> )
			
		THEN
			loadStepLeft := loadStepRight := 0;
			//loadSet := 20;
			loadSet := COMPLETE;
		END_IF
		
	20: //left robot to bottom insertion - module only
		leftMaterial := pair.bottom;
		IF 
			loadingSequenceWB(
				robot:= robotLeft, 
				table:= stagingTableLeft, 
				loadStep:= loadStepLeft, 
				slot:= iSlotLeft,
				suctions:= bottomSuction,
				surfaceID:= Surface.BOTTOM, 
				material:= pair.bottom, 
				fail=> failLeft)
		THEN
			loadSet := COMPLETE;
		END_IF
	
	COMPLETE:
		loadSet := 0;
		loadStepLeft := loadStepRight := 0;
		
		robotLeft.release(sectionID);
		robotRight.release(sectionID);
		
		loadWB := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="splitCombinedMaterials" Id="{2d4261c8-bf9d-46e0-bbeb-a131d51afe13}" FolderPath="Staging\Staging Template\">
      <Declaration><![CDATA[METHOD splitCombinedMaterials : BOOL
VAR_IN_OUT
	materialID : STRING;
	splitMaterial : STRING;
END_VAR
VAR
	i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FindAndSplitChar(
	sSeparatorChar:= '_', 
	pSrcString:= ADR(materialID), 
	
	pLeftString:= ADR(splitMaterial), 
	nLeftSize:= SIZEOF(splitMaterial), 
	
	pRightString:= ADR(materialID), 
	nRightSize:= SIZEOF(materialID), 
	
	bSearchFromRight:= FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="stage" Id="{dba40ed0-ce21-4fae-ad82-5c2c7af91ea1}" FolderPath="Staging\">
      <Declaration><![CDATA[METHOD stage : BOOL
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[sectionID := SectionEnum.WOOD_BUNK;
(*
IF NOT robotLeft.operational OR NOT robotLeft.operational THEN
	error := TRUE;
	RETURN;
END_IF

IF NOT (robotLeft.reserve(reserveRequest := sectionID) AND robotRight.reserve(reserveRequest := sectionID)) THEN
	RETURN;
END_IF

IF NOT (robotLeft.tool = sectionID AND robotRight.tool = sectionID) THEN //robots have wrong tool
	changeRobotsEOAT(robot := robotLeft, targetTool := sectionID); //wait for robots to finish changing tools
	changeRobotsEOAT(robot := robotRight, targetTool := sectionID);
	RETURN;
END_IF
*)

CASE stageSet OF
	0: //create staging template
		IF generateStagingTemplate() THEN
			stageSet := 10;
		END_IF
	
	10: //staging sequence
		IF stagingSequenceLeft(fail => failLeft) AND stagingSequenceRight(fail => failRight)
			(*
			stagingSequence(				
				robot:= robotLeft, 
				commands:= robotLeftOutputs,
				template:= stagingTemplateLeft,
				table:= stagingTableLeft,  
				magazine:= magazineLeft, 
				stagingStep:= stageStepLeft, 
				iSlot:= iSlotLeft,
				fail=> failLeft)
			
			AND
			stagingSequence(
				robot:= robotRight, 
				commands:= robotRightOutputs,
				template:= stagingTemplateRight, 
				magazine:= magazineRight, 
				table:= stagingTableRight, 
				stagingStep:= stageStepRight, 
				iSlot:= iSlotRight,
				fail=> )
			*)
		THEN
			stageStepLeft := stageStepRight := 0;
			iSlotLeft := iSlotRight := 1;
			
			stageSet := COMPLETE;
		END_IF
		
	COMPLETE:
		stagingTemplateRight.clear(); //clear the staging templates
		stagingTemplateLeft.clear();
		
		robotLeft.release(sectionID); //release the robots
		robotRight.release(sectionID);
		
		stageSet := 0;
		stage := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="stagingSequenceLeft" Id="{06759290-b8ea-4e3b-a0ce-b0e9e30a73f5}" FolderPath="Staging\">
      <Declaration><![CDATA[METHOD stagingSequenceLeft : BOOL
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	magazineColumn : INT; //valid positions start from 1
END_VAR
VAR CONSTANT
	WIP : INT := 0;
	PASSED : INT := 1;
	FAILED : INT := 2;
	suctionDistance : INT := 15;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF //staging table is full or matches staging template
	stagingTableLeft.isFull() OR iSlotLeft > 10 OR 
	MEMCMP(ADR(stagingTableLeft.slots), ADR(stagingTemplateLeft.slots), SIZEOF(stagingTableLeft.slots)) = 0
THEN
	stagingSequenceLeft := TRUE;
	RETURN;
END_IF

IF stagingTemplateLeft.slots[iSlotLeft] = '' THEN
	iSlotLeft := iSlotLeft + 1;
	RETURN;
	
ELSIF robotLeft.offline THEN
	fail := TRUE;
	RETURN;
	
ELSIF //robot in used by other section, or has wrong tool and is not done changing
	NOT robotLeft.reserve(reserveRequest := sectionID) OR_ELSE
	(robotLeft.tool <> SectionID AND_THEN NOT changeRobotsEOAT(robot := robotLeft, targetTool := sectionID))
THEN
	RETURN;
END_IF

//follow the stagingTemplateLeft as is
CASE stageStepLeft OF
	0:
		robotLeft.clearCommand();
		
		IF robotLeft.Ready THEN
			stageStepLeft := 10;
		END_IF
		
	10:
		IF NOT magazineLeft.findSlot(materialID := stagingTemplateLeft.slots[iSlotLeft], atSlot => magazineColumn) THEN
			fail := TRUE;
			RETURN;
		END_IF
			
		IF robotLeft.eoatDistance < suctionDistance THEN //robot is grabbing material
			robotLeft.CarryMaterial := magazineLeft.slots[magazineColumn];
		END_IF
		
		IF robotLeft.Done THEN
			stageStepLeft := COMPLETE;
			RETURN;
		ELSIF stagingTableLeft.occupied[iSlotLeft] THEN
			stageStepLeft := 20;
			RETURN;
		END_IF
		
		robotLeft.setGroup(group := 1, value := A21.STAGE_BUNK);
		robotLeft.setGroup(group := 2, value := magazineColumn);
		robotLeft.setGroup(group := 3, value := iSlotLeft);
		
	20:
		IF
			stagingTableLeft.occupied[iSlotLeft] AND //staging table slot is occupied
			stagingTableLeft.slots[iSlotLeft] = '' AND //staging table has not recorded a bunk
			robotLeft.CarryMaterial <> '' //robot is carrying a bunk
		THEN
			stagingTableLeft.place(i := iSlotLeft, materialID := robotLeft.CarryMaterial);
			robotLeft.CarryMaterial := '';
		END_IF
		
		IF robotLeft.Done THEN
			stageStepLeft := COMPLETE;
			RETURN;
		END_IF
		
	COMPLETE:
		(*
		IF stagingTableLeft.occupied[iSlotLeft] THEN //move from gripper to table
			stagingTableLeft.place(i := iSlotLeft, materialID := robotLeft.CarryMaterial);
			robotLeft.CarryMaterial := '';
		END_IF
		*)
		robotLeft.clearCommand();
		
		iSlotLeft := iSlotLeft + 1;
		stageStepLeft := 0;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="stagingSequenceLeft_old" Id="{af028099-bde6-4a6b-b9e3-a9176b37dc19}" FolderPath="x_Reworking\">
      <Declaration><![CDATA[METHOD stagingSequenceLeft_old : BOOL
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	magazineColumn : INT; //valid positions start from 1
END_VAR
VAR CONSTANT
	WIP : INT := 0;
	PASSED : INT := 1;
	FAILED : INT := 2;
	suctionDistance : INT := 15;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
IF //staging table is full or matches staging template
	stagingTableLeft.isFull() OR iSlotLeft > 10 OR 
	MEMCMP(ADR(stagingTableLeft.slots), ADR(stagingTemplateLeft.slots), SIZEOF(stagingTableLeft.slots)) = 0
THEN
	stagingSequenceLeft_old := TRUE;
	RETURN;
END_IF

IF stagingTemplateLeft.slots[iSlotLeft] = '' THEN
	iSlotLeft := iSlotLeft + 1;
	RETURN;
END_IF

IF //robot in used by other section or has wrong tool
	NOT robotLeft.reserve(reserveRequest := sectionID) OR_ELSE
	(robotLeft.tool <> SectionID AND_THEN changeRobotsEOAT(robot := robotLeft, targetTool := sectionID))
THEN
	RETURN;
END_IF

//follow the stagingTemplateLeft as is
CASE stageStepLeft OF
	0:
		robotLeft.clearCommand();
		MEMSET(ADR(robotLeftOutputs), 0, SIZEOF(robotLeftOutputs));
		
		IF robotLeft.Ready THEN
			stageStepLeft := 10;
		END_IF
		
	10:
		IF NOT magazineLeft.findSlot(materialID := stagingTemplateLeft.slots[iSlotLeft], atSlot => magazineColumn) THEN
			fail := TRUE;
			RETURN;
		END_IF
			
		IF robotLeft.eoatDistance < suctionDistance THEN //robot is grabbing material
			robotLeft.CarryMaterial := magazineLeft.slots[magazineColumn];
		END_IF
		
		IF robotLeft.Done THEN
			stageStepLeft := COMPLETE;
			RETURN;
		END_IF
		
		MEMSET(ADR(robotLeftOutputs), 0, SIZEOF(robotLeftOutputs));
		robotLeft.setGroup(group := 1, value := A21.STAGE_BUNK);
		robotLeft.setGroup(group := 2, value := magazineColumn);
		robotLeft.setGroup(group := 3, value := iSlotLeft);
		robotLeftOutputs[1] := A21.STAGE_BUNK;
		robotLeftOutputs[2] := magazineColumn;
		robotLeftOutputs[3] := iSlotLeft;
		
		robotLeft.setCommand(robotLeftOutputs);
		
	(*
	20:
		
		(*
		MEMSET(ADR(robotLeftOutputs), 0, SIZEOF(robotLeftOutputs));
		robotLeftOutputs[1] := A21.STAGE_BUNK;
		robotLeftOutputs[2] := magazineColumn;
		robotLeftOutputs[3] := iSlotLeft;
		robotLeft.commandEx(robotLeftOutputs);
		*)
		
		robotLeft.commandEx(robotLeftOutputs);
		
		IF stagingTableLeft.occupied[magazineColumn] THEN //move from gripper to table
			stagingTableLeft.place(i := iSlotLeft, materialID := robotLeftMaterial);
			robotLeftMaterial := '';
			stageStepLeft := 30;
		END_IF
				
	30:
		robotLeft.commandEx(robotLeftOutputs);
		IF robotLeft.Done THEN
			stageStepLeft := COMPLETE;
			RETURN;
		END_IF
	*)
	COMPLETE:
		IF stagingTableLeft.occupied[iSlotLeft] THEN //move from gripper to table
			stagingTableLeft.place(i := iSlotLeft, materialID := robotLeft.suspendedMaterial);
			robotLeft.CarryMaterial := '';
		END_IF
		
		
		robotLeft.clearCommand();
		MEMSET(ADR(robotLeftOutputs), 0, SIZEOF(robotLeftOutputs));
		
		iSlotLeft := iSlotLeft + 1;
		stageStepLeft := 0;
END_CASE
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="stagingSequenceRight" Id="{3bcc491e-4e80-49d6-ab0f-e33003c4b67f}" FolderPath="Staging\">
      <Declaration><![CDATA[METHOD stagingSequenceRight : BOOL
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	magazineColumn : INT := -1; //valid positions start from 1
END_VAR
VAR CONSTANT
	WIP : INT := 0;
	PASSED : INT := 1;
	FAILED : INT := 2;
	suctionDistance : INT := 15;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF //staging table is full or matches staging template
	stagingTableRight.isFull() OR iSlotRight > 10 OR 
	MEMCMP(ADR(stagingTableRight.slots), ADR(stagingTemplateRight.slots), SIZEOF(stagingTableRight.slots)) = 0
THEN
	stagingSequenceRight := TRUE;
	RETURN;
END_IF

IF stagingTemplateRight.slots[iSlotRight] = '' THEN
	iSlotRight := iSlotRight + 1;
	RETURN;
	
ELSIF robotRight.offline THEN
	fail := TRUE;
	RETURN;
	
ELSIF //robot in used by other section or has wrong tool
	NOT robotRight.reserve(reserveRequest := sectionID) OR_ELSE
	(robotRight.tool <> SectionID AND_THEN changeRobotsEOAT(robot := robotRight, targetTool := sectionID))
THEN
	RETURN;
END_IF

//follow the stagingTemplateRight as is
CASE stageStepRight OF
	0:
		robotRight.clearCommand();
		
		IF robotRight.Ready THEN
			stageStepRight := 10;
		END_IF
		
	10:
		IF NOT magazineRight.findSlot(materialID := stagingTemplateRight.slots[iSlotRight], atSlot => magazineColumn) THEN
			fail := TRUE;
			RETURN;
		END_IF
			
		IF robotRight.eoatDistance < suctionDistance THEN //robot is grabbing material
			robotRight.CarryMaterial := magazineRight.slots[magazineColumn];
		END_IF
		
		IF robotRight.Done THEN
			stageStepRight := COMPLETE;
			RETURN;
		ELSIF stagingTableRight.occupied[iSlotRight] THEN
			stageStepRight := 20;
			RETURN;
		END_IF
		
		robotRight.setGroup(group := 1, value := A21.STAGE_BUNK);
		robotRight.setGroup(group := 2, value := magazineColumn);
		robotRight.setGroup(group := 3, value := iSlotRight);
		
	20:
		IF
			stagingTableRight.occupied[iSlotRight] AND //staging table slot is occupied
			stagingTableRight.slots[iSlotRight] = '' AND //staging table has not recorded a bunk
			robotRight.CarryMaterial <> '' //robot is carrying a bunk
		THEN
			stagingTableRight.place(i := iSlotRight, materialID := robotRight.CarryMaterial);
			robotRight.CarryMaterial := '';
		END_IF
		
		IF robotRight.Done THEN
			stageStepRight := COMPLETE;
			RETURN;
		END_IF
		
	COMPLETE:
		(*
		IF stagingTableRight.occupied[iSlotRight] THEN //move from gripper to table
			stagingTableRight.place(i := iSlotRight, materialID := robotRight.CarryMaterial);
			robotRight.CarryMaterial := '';
		END_IF
		*)
		robotRight.clearCommand();
		
		iSlotRight := iSlotRight + 1;
		stageStepRight := 0;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ModuleA21_old">
      <LineId Id="3855" Count="124" />
      <LineId Id="4035" Count="1" />
      <LineId Id="3980" Count="0" />
      <LineId Id="3983" Count="47" />
      <LineId Id="3665" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.callLocalModules">
      <LineId Id="32" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="6" Count="9" />
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="21" Count="6" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.changeRobotsEOAT">
      <LineId Id="10" Count="0" />
      <LineId Id="62" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="48" Count="2" />
      <LineId Id="46" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="51" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.createStagingArrayLeft">
      <LineId Id="12" Count="3" />
      <LineId Id="44" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="46" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="27" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.createStagingArrayRight">
      <LineId Id="12" Count="3" />
      <LineId Id="44" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="49" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="27" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.generateStagingTemplate">
      <LineId Id="400" Count="1" />
      <LineId Id="441" Count="0" />
      <LineId Id="440" Count="0" />
      <LineId Id="402" Count="7" />
      <LineId Id="411" Count="6" />
      <LineId Id="419" Count="0" />
      <LineId Id="422" Count="6" />
      <LineId Id="421" Count="0" />
      <LineId Id="430" Count="0" />
      <LineId Id="429" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadCIP">
      <LineId Id="321" Count="22" />
      <LineId Id="345" Count="14" />
      <LineId Id="361" Count="12" />
      <LineId Id="375" Count="18" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadingSequenceCIP">
      <LineId Id="25" Count="4" />
      <LineId Id="58" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="158" Count="0" />
      <LineId Id="59" Count="3" />
      <LineId Id="116" Count="1" />
      <LineId Id="162" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="166" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="159" Count="1" />
      <LineId Id="82" Count="1" />
      <LineId Id="155" Count="2" />
      <LineId Id="142" Count="2" />
      <LineId Id="146" Count="4" />
      <LineId Id="169" Count="0" />
      <LineId Id="152" Count="2" />
      <LineId Id="145" Count="0" />
      <LineId Id="94" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadingSequenceWB">
      <LineId Id="683" Count="5" />
      <LineId Id="970" Count="1" />
      <LineId Id="689" Count="6" />
      <LineId Id="975" Count="0" />
      <LineId Id="696" Count="2" />
      <LineId Id="883" Count="0" />
      <LineId Id="885" Count="0" />
      <LineId Id="980" Count="0" />
      <LineId Id="886" Count="0" />
      <LineId Id="884" Count="0" />
      <LineId Id="878" Count="0" />
      <LineId Id="981" Count="1" />
      <LineId Id="984" Count="0" />
      <LineId Id="983" Count="0" />
      <LineId Id="881" Count="1" />
      <LineId Id="879" Count="0" />
      <LineId Id="968" Count="0" />
      <LineId Id="701" Count="4" />
      <LineId Id="936" Count="0" />
      <LineId Id="825" Count="0" />
      <LineId Id="715" Count="0" />
      <LineId Id="818" Count="2" />
      <LineId Id="817" Count="0" />
      <LineId Id="887" Count="0" />
      <LineId Id="816" Count="0" />
      <LineId Id="824" Count="0" />
      <LineId Id="780" Count="0" />
      <LineId Id="791" Count="2" />
      <LineId Id="943" Count="0" />
      <LineId Id="790" Count="0" />
      <LineId Id="781" Count="1" />
      <LineId Id="846" Count="2" />
      <LineId Id="894" Count="0" />
      <LineId Id="852" Count="1" />
      <LineId Id="977" Count="0" />
      <LineId Id="976" Count="0" />
      <LineId Id="895" Count="0" />
      <LineId Id="934" Count="0" />
      <LineId Id="929" Count="1" />
      <LineId Id="900" Count="0" />
      <LineId Id="931" Count="1" />
      <LineId Id="928" Count="0" />
      <LineId Id="888" Count="0" />
      <LineId Id="942" Count="0" />
      <LineId Id="849" Count="0" />
      <LineId Id="734" Count="2" />
      <LineId Id="739" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadingSequenceWB_old">
      <LineId Id="683" Count="15" />
      <LineId Id="883" Count="0" />
      <LineId Id="885" Count="1" />
      <LineId Id="884" Count="0" />
      <LineId Id="878" Count="0" />
      <LineId Id="880" Count="2" />
      <LineId Id="879" Count="0" />
      <LineId Id="699" Count="8" />
      <LineId Id="825" Count="0" />
      <LineId Id="715" Count="0" />
      <LineId Id="818" Count="2" />
      <LineId Id="817" Count="0" />
      <LineId Id="887" Count="0" />
      <LineId Id="821" Count="0" />
      <LineId Id="816" Count="0" />
      <LineId Id="824" Count="0" />
      <LineId Id="780" Count="0" />
      <LineId Id="791" Count="3" />
      <LineId Id="796" Count="0" />
      <LineId Id="790" Count="0" />
      <LineId Id="781" Count="1" />
      <LineId Id="846" Count="2" />
      <LineId Id="894" Count="0" />
      <LineId Id="852" Count="1" />
      <LineId Id="895" Count="0" />
      <LineId Id="934" Count="0" />
      <LineId Id="929" Count="1" />
      <LineId Id="900" Count="0" />
      <LineId Id="931" Count="1" />
      <LineId Id="928" Count="0" />
      <LineId Id="888" Count="0" />
      <LineId Id="897" Count="0" />
      <LineId Id="856" Count="0" />
      <LineId Id="859" Count="0" />
      <LineId Id="877" Count="0" />
      <LineId Id="857" Count="0" />
      <LineId Id="860" Count="0" />
      <LineId Id="933" Count="0" />
      <LineId Id="849" Count="0" />
      <LineId Id="753" Count="2" />
      <LineId Id="760" Count="0" />
      <LineId Id="777" Count="0" />
      <LineId Id="757" Count="0" />
      <LineId Id="771" Count="1" />
      <LineId Id="765" Count="0" />
      <LineId Id="758" Count="0" />
      <LineId Id="774" Count="1" />
      <LineId Id="764" Count="0" />
      <LineId Id="756" Count="0" />
      <LineId Id="822" Count="0" />
      <LineId Id="734" Count="3" />
      <LineId Id="739" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadingSequenceWB_simple">
      <LineId Id="683" Count="15" />
      <LineId Id="924" Count="0" />
      <LineId Id="926" Count="2" />
      <LineId Id="925" Count="0" />
      <LineId Id="883" Count="0" />
      <LineId Id="916" Count="0" />
      <LineId Id="942" Count="2" />
      <LineId Id="937" Count="0" />
      <LineId Id="931" Count="5" />
      <LineId Id="930" Count="0" />
      <LineId Id="920" Count="0" />
      <LineId Id="885" Count="0" />
      <LineId Id="938" Count="1" />
      <LineId Id="941" Count="0" />
      <LineId Id="940" Count="0" />
      <LineId Id="886" Count="0" />
      <LineId Id="921" Count="0" />
      <LineId Id="884" Count="0" />
      <LineId Id="910" Count="0" />
      <LineId Id="700" Count="6" />
      <LineId Id="923" Count="0" />
      <LineId Id="707" Count="0" />
      <LineId Id="905" Count="1" />
      <LineId Id="945" Count="11" />
      <LineId Id="982" Count="0" />
      <LineId Id="958" Count="1" />
      <LineId Id="983" Count="0" />
      <LineId Id="960" Count="5" />
      <LineId Id="907" Count="0" />
      <LineId Id="967" Count="0" />
      <LineId Id="981" Count="0" />
      <LineId Id="968" Count="10" />
      <LineId Id="980" Count="0" />
      <LineId Id="966" Count="0" />
      <LineId Id="734" Count="3" />
      <LineId Id="739" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.loadWB">
      <LineId Id="1045" Count="0" />
      <LineId Id="1051" Count="0" />
      <LineId Id="1046" Count="4" />
      <LineId Id="899" Count="0" />
      <LineId Id="1002" Count="0" />
      <LineId Id="1001" Count="0" />
      <LineId Id="1035" Count="0" />
      <LineId Id="1037" Count="0" />
      <LineId Id="1052" Count="0" />
      <LineId Id="918" Count="1" />
      <LineId Id="1054" Count="0" />
      <LineId Id="922" Count="0" />
      <LineId Id="1057" Count="1" />
      <LineId Id="1055" Count="1" />
      <LineId Id="923" Count="3" />
      <LineId Id="929" Count="0" />
      <LineId Id="1059" Count="0" />
      <LineId Id="999" Count="0" />
      <LineId Id="930" Count="1" />
      <LineId Id="1039" Count="0" />
      <LineId Id="1043" Count="0" />
      <LineId Id="932" Count="2" />
      <LineId Id="937" Count="1" />
      <LineId Id="995" Count="0" />
      <LineId Id="939" Count="3" />
      <LineId Id="1003" Count="0" />
      <LineId Id="943" Count="2" />
      <LineId Id="948" Count="1" />
      <LineId Id="996" Count="0" />
      <LineId Id="950" Count="3" />
      <LineId Id="1004" Count="0" />
      <LineId Id="954" Count="5" />
      <LineId Id="1040" Count="1" />
      <LineId Id="960" Count="2" />
      <LineId Id="965" Count="1" />
      <LineId Id="997" Count="0" />
      <LineId Id="967" Count="3" />
      <LineId Id="1005" Count="0" />
      <LineId Id="971" Count="2" />
      <LineId Id="976" Count="1" />
      <LineId Id="998" Count="0" />
      <LineId Id="978" Count="3" />
      <LineId Id="1006" Count="0" />
      <LineId Id="982" Count="2" />
      <LineId Id="1038" Count="0" />
      <LineId Id="985" Count="0" />
      <LineId Id="1013" Count="1" />
      <LineId Id="1044" Count="0" />
      <LineId Id="1016" Count="2" />
      <LineId Id="1020" Count="5" />
      <LineId Id="986" Count="0" />
      <LineId Id="1026" Count="2" />
      <LineId Id="1015" Count="0" />
      <LineId Id="987" Count="7" />
      <LineId Id="278" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.splitCombinedMaterials">
      <LineId Id="15" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.stage">
      <LineId Id="819" Count="12" />
      <LineId Id="887" Count="0" />
      <LineId Id="832" Count="6" />
      <LineId Id="891" Count="0" />
      <LineId Id="890" Count="0" />
      <LineId Id="840" Count="2" />
      <LineId Id="888" Count="0" />
      <LineId Id="844" Count="2" />
      <LineId Id="848" Count="10" />
      <LineId Id="860" Count="23" />
      <LineId Id="657" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.stagingSequenceLeft">
      <LineId Id="421" Count="9" />
      <LineId Id="529" Count="0" />
      <LineId Id="723" Count="0" />
      <LineId Id="693" Count="0" />
      <LineId Id="695" Count="0" />
      <LineId Id="697" Count="0" />
      <LineId Id="722" Count="0" />
      <LineId Id="524" Count="4" />
      <LineId Id="522" Count="0" />
      <LineId Id="432" Count="2" />
      <LineId Id="498" Count="0" />
      <LineId Id="573" Count="0" />
      <LineId Id="575" Count="0" />
      <LineId Id="499" Count="3" />
      <LineId Id="435" Count="0" />
      <LineId Id="618" Count="2" />
      <LineId Id="617" Count="0" />
      <LineId Id="607" Count="0" />
      <LineId Id="685" Count="0" />
      <LineId Id="681" Count="0" />
      <LineId Id="706" Count="4" />
      <LineId Id="588" Count="0" />
      <LineId Id="721" Count="0" />
      <LineId Id="719" Count="1" />
      <LineId Id="495" Count="0" />
      <LineId Id="664" Count="2" />
      <LineId Id="447" Count="0" />
      <LineId Id="698" Count="0" />
      <LineId Id="711" Count="5" />
      <LineId Id="705" Count="0" />
      <LineId Id="717" Count="1" />
      <LineId Id="701" Count="2" />
      <LineId Id="700" Count="0" />
      <LineId Id="704" Count="0" />
      <LineId Id="457" Count="0" />
      <LineId Id="687" Count="0" />
      <LineId Id="622" Count="0" />
      <LineId Id="621" Count="0" />
      <LineId Id="682" Count="0" />
      <LineId Id="627" Count="0" />
      <LineId Id="631" Count="0" />
      <LineId Id="468" Count="0" />
      <LineId Id="461" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.stagingSequenceLeft_old">
      <LineId Id="696" Count="0" />
      <LineId Id="421" Count="9" />
      <LineId Id="529" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="523" Count="5" />
      <LineId Id="522" Count="0" />
      <LineId Id="432" Count="2" />
      <LineId Id="498" Count="0" />
      <LineId Id="573" Count="2" />
      <LineId Id="499" Count="3" />
      <LineId Id="435" Count="0" />
      <LineId Id="618" Count="2" />
      <LineId Id="617" Count="0" />
      <LineId Id="607" Count="0" />
      <LineId Id="589" Count="0" />
      <LineId Id="683" Count="0" />
      <LineId Id="588" Count="0" />
      <LineId Id="612" Count="0" />
      <LineId Id="614" Count="2" />
      <LineId Id="613" Count="0" />
      <LineId Id="495" Count="0" />
      <LineId Id="505" Count="0" />
      <LineId Id="664" Count="2" />
      <LineId Id="442" Count="2" />
      <LineId Id="601" Count="0" />
      <LineId Id="446" Count="1" />
      <LineId Id="530" Count="0" />
      <LineId Id="537" Count="0" />
      <LineId Id="584" Count="0" />
      <LineId Id="577" Count="0" />
      <LineId Id="539" Count="4" />
      <LineId Id="576" Count="0" />
      <LineId Id="586" Count="0" />
      <LineId Id="579" Count="0" />
      <LineId Id="546" Count="0" />
      <LineId Id="549" Count="2" />
      <LineId Id="572" Count="0" />
      <LineId Id="547" Count="1" />
      <LineId Id="568" Count="0" />
      <LineId Id="580" Count="0" />
      <LineId Id="570" Count="1" />
      <LineId Id="587" Count="0" />
      <LineId Id="569" Count="0" />
      <LineId Id="456" Count="1" />
      <LineId Id="622" Count="0" />
      <LineId Id="621" Count="0" />
      <LineId Id="648" Count="0" />
      <LineId Id="627" Count="0" />
      <LineId Id="630" Count="1" />
      <LineId Id="468" Count="0" />
      <LineId Id="460" Count="3" />
      <LineId Id="5" Count="0" />
      <LineId Id="697" Count="0" />
    </LineIds>
    <LineIds Name="ModuleA21_old.stagingSequenceRight">
      <LineId Id="754" Count="10" />
      <LineId Id="836" Count="0" />
      <LineId Id="767" Count="2" />
      <LineId Id="837" Count="0" />
      <LineId Id="772" Count="63" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>